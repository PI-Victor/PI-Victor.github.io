<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      http-equiv="X-UA-Compatible"
      content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css"
      integrity="sha512-EZLkOqwILORob+p0BXZc+Vm3RgJBOe1Iq/0fiI7r/wJgzOFZMlsqTa29UEl6v6U6gsV4uIpsNZoV32YZqrCRCQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"
      integrity="sha512-o5v54Kh5PH0dgnf9ei0L+vMRsbm5fvIvnR/XkrZZjN4mqdaeH7PW66tumBoQVIaKNVrLCZiBEfHzRY4JJSMK/Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      href="https://fonts.cdnfonts.com/css/raleway-5"
      rel="stylesheet" />
    <link
      href="assets/main.css"
      rel="stylesheet" />
    <title>About gRPC and gRPC-web</title>
  </head>
  <body>
    <div
      class="container"
      id="main">
      <div class="row">
        <div class="container">
          <a
            link=""
            href="index.html">
            Home
          </a>
        </div>
      </div>
      <div class="row">
        <div
          class="container"
          id="content">
          <p>In this posts we will explore how to make a frontend, written in React, talk to
a gRPC service written in Go.</p>
<h4 id="grpc-and-the-web">gRPC and the web</h4>
<p>Browsers <a href="https://grpc.io/blog/state-of-grpc-web/#the-grpc-web-spec">can&#39;t talk to gRPC services
natively</a> so the
solution came in the form of a proxy that could translate the frontend http
requests made by the browser to gRPC calls that the backend gRPC service could
understand.<br>These solutions are differently implemented in both libraries that emerged to
tackle this problem.</p>
<h4 id="google-grpc-web">Google gRPC-web</h4>
<p><a href="https://github.com/grpc/grpc-web">This library</a> uses
 <a href="https://en.wikipedia.org/wiki/XMLHttpRequest">XHR</a> transport only so that it
 guarantees backwards compatibility with older browsers. It also provides no
 proxy out of the bag to translate the frontend requests to native gRPC calls,
 in order to use this, you need something like Envoy between the frontend and
 your gRPC service.<br> Using this is pretty straight forward:</p>
<ul>
<li>Generate the commonjs (or experimental typescript) client stubs, based on
your proto file set</li>
<li>Point the frontend client instance created using the above generated stubs
towards the Envoy proxy</li>
<li>Configure the Envoy proxy to point to your gRPC service instance</li>
<li>profit!</li>
</ul>
<h4 id="improbable-grpc-web">Improbable gRPC-web</h4>
<p>If you are in Go land, this is probably the best library to use since it has a
<a href="https://github.com/improbable-eng/grpc-web/tree/master/go/grpcweb">Go library that provides hassle free translation of browser
requests</a>,
that you can use directly in your Go code. If you are not in Go land, that&#39;s
okay, they also provide a <a href="https://github.com/improbable-eng/grpc-web/tree/master/go/grpcwebproxy">proxy
binary</a>
that can do exactly what the library does, this can make it easier to avoid
heavier solutions such as Envoy. Using the improbable library has the
following steps:</p>
<ul>
<li>Generate the stubs using commonjs (optionally the typescript definitions
using the <a href="https://github.com/improbable-eng/ts-protoc-gen">ts-protoc-gen</a>
plugin)</li>
<li>Point your frontend client instance directly at your gRPC service</li>
<li>In your Go code wrap the gRPC server with the translation capable library
and pass it to a http server instance:</li>
</ul>
<pre><code class="hljs language-Go"><span class="hljs-keyword">import</span> (
    <span class="hljs-string">&quot;github.com/improbable-eng/grpc-web/go/grpcweb&quot;</span>
    <span class="hljs-string">&quot;github.com/gorilla/mux&quot;</span>
    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span>
)

grpcServer := grpc.NewServer()
wrappedGrpcServer := grpcweb.WrapServer(grpcServer)
router := mux.NewRouter()
<span class="hljs-comment">// stripPrefix is a function that will strip the &#x27;/grpc&#x27; from the url path so that</span>
<span class="hljs-comment">// the incoming requests is handled properly.</span>
router.PathPrefix(<span class="hljs-string">&quot;/grpc&quot;</span>).Handler(stripPrefix(<span class="hljs-string">&quot;/grpc&quot;</span>, wrappedGrpcServer))
httpServer := &amp;http.Server{
    Addr:         address,
    Handler:      router,
}
<span class="hljs-keyword">if</span> err := httpServer.ListenAndServe(); err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">if</span> err != http.ErrServerClosed {
        <span class="hljs-built_in">panic</span>(err)
    }
}
</code></pre>
<h4 id="generating-frontend-client-stubs">Generating frontend client stubs</h4>
<p>In order to generate the client stubs to use within your chosen library you need
the protoc plugin. <a href="https://github.com/grpc/grpc-web#code-generator-plugin">Download and
install</a> the
protoc-gen-grpc-web plugin and generate the stubs:</p>
<pre><code class="hljs language-bash">$ protoc --proto_path=my/relative/path \
    --js_out=import_style=commonjs:path/to/frontend/api \
    --grpc-web_out=import_style=commonjs,mode=grpcwebtext:path/to/frontend/api \
    my-protoset.proto
</code></pre>
<p>This will generate two files, <code>myservice_pb.js</code> and <code>myservice_grpc_web_pb.js</code>.
The first one contains the protobuf messages translated to javascript, and
another that basically has the grpc-web service implementation that allows you
to create a client instance and send requests to the backend.</p>
<p>in your <code>src/v1/api/index.js</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyServicePromiseClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./v1/myservice_grpc_web_pb.js&#x27;</span>;
<span class="hljs-keyword">import</span> {
    <span class="hljs-title class_">ListMessageRequest</span>,
    <span class="hljs-title class_">MyMessageMetadata</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./v1/myservice_pb.js&#x27;</span>

<span class="hljs-comment">// create a new client with the ip address of the gRPC service</span>
<span class="hljs-comment">// this can be either the Envoy proxy or your native gRPC service </span>
<span class="hljs-comment">// wrapped in the improbable proxy library.</span>
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServicePromiseClient</span>(<span class="hljs-string">&#x27;http://127.0.0.1:8090&#x27;</span>)

<span class="hljs-keyword">const</span> <span class="hljs-title function_">ListSomething</span> = <span class="hljs-keyword">async</span> =&gt; {
    <span class="hljs-keyword">let</span> listMessageRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListMessageRequest</span>();
    <span class="hljs-keyword">let</span> metadata = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMessageMetadata</span>();
    metadata.<span class="hljs-title function_">setMetadataTimestamp</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())
    listMessageRequest.<span class="hljs-title function_">setMetadata</span>(metadata)
    <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">listMessage</span>(listMessageRequest)
    <span class="hljs-keyword">return</span> resp.<span class="hljs-title function_">toObject</span>()
}

<span class="hljs-keyword">export</span> { <span class="hljs-title class_">ListSomething</span> };
</code></pre>
<p>for react: in your <code>src/components/mycomponent/component.js</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ListSomething</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../api&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>([]);
    <span class="hljs-keyword">const</span> [err, setError] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
    
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">listSomething</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title class_">ListSomething</span>();
                <span class="hljs-title function_">setList</span>(resp.<span class="hljs-property">myList</span>);
            } <span class="hljs-keyword">catch</span>(err) {
                <span class="hljs-title function_">setError</span>(err)
            }
        }
        <span class="hljs-title function_">listSomething</span>()
    }, [])
}
</code></pre>
<p>The above simply does a request to the gRPC server to fetch a list and store the
result in the component&#39;s state. This uses the API we defined above to create
the request and attach metadata to it. You can also pass params to the API and
set fields and other metadata, such as auth tokens, labels et all based on your
 needs.</p>
<h4 id="conclusion">Conclusion</h4>
<p>I hope this post has cleared up some basics about building frontend applications
that can talk to gRPC services. The grpc-web client can do both unary calls but
also streaming. For the different options (server side streaming, client side
streaming, bi-directional) you have to consult the gRPC-web library
documentation to see which one is supported.</p>

        </div>
      </div>
      <div class="row">
        <div
          class="container"
          id="slugs">
          <a>#gRPC&nbsp;</a>
          <a>#gRPC-web&nbsp;</a>
          <a>#Go&nbsp;</a>
          <a>#React&nbsp;</a>
          <a>#JavaScript&nbsp;</a>
        </div>
      </div>
      <div class="row">
        <div
          class="container"
          style="text-align: center; padding-top: 15px">
          <p>
            Made by me, compiled with
            <a href="https://github.com/pi-victor/pi-victor.github.io"
              >typescript and deno</a
            >.
          </p>
        </div>
      </div>
    </div>
  </body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</html>
